<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anbu Malligarjun — Skills Tree</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Montserrat:ital,wght@0,300;0,400;0,600;1,300&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #03070b;
            --primary-glow: 0, 255, 170;
            --glass-bg: rgba(10, 15, 20, 0.6);
            --glass-border: rgba(255, 255, 255, 0.1);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { 
            width: 100%; height: 100%; overflow: auto; 
            background: var(--bg-color); 
            font-family: 'Montserrat', sans-serif;
            color: white;
            -webkit-font-smoothing: antialiased;
        }

        #app-container { position: relative; width: 100%; min-height: 100vh; overflow: visible; }
        canvas#webgl-canvas { display: block; position: absolute; inset: 0; outline: none; }

        /* ── SVG Overlay for connecting lines ── */
        #svg-overlay {
            position: absolute; inset: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        /* ── Loader ── */
        #loader {
            position: fixed; inset: 0; background: var(--bg-color);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 1000; transition: opacity 1.2s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .loader-ring {
            width: 80px; height: 80px;
            border: 2px solid rgba(var(--primary-glow), 0.1);
            border-top: 2px solid rgba(var(--primary-glow), 1);
            border-radius: 50%;
            animation: spin 1.5s linear infinite;
            margin-bottom: 24px;
            box-shadow: 0 0 20px rgba(var(--primary-glow), 0.2);
        }
        #loader-title {
            font-family: 'Cinzel', serif; font-size: 16px; letter-spacing: 0.4em;
            text-transform: uppercase; color: rgba(255,255,255,0.9);
            text-shadow: 0 0 10px rgba(var(--primary-glow), 0.5);
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* ── Skill Tags ── */
        .skill-tag {
            position: absolute;
            transform: translate(-50%, -50%);
            pointer-events: auto; cursor: pointer;
            font-family: 'Montserrat', sans-serif; font-size: 11px; font-weight: 600; letter-spacing: 0.1em;
            padding: 6px 14px;
            background: rgba(5, 10, 15, 0.65);
            backdrop-filter: blur(4px); -webkit-backdrop-filter: blur(4px);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 20px;
            white-space: nowrap;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            opacity: 0; user-select: none; z-index: 20;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }
        .skill-tag:hover {
            transform: translate(-50%, -60%) scale(1.1);
            background: rgba(20, 25, 30, 0.85);
            z-index: 30;
        }
        .skill-tag.active {
            transform: translate(-50%, -60%) scale(1.15);
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255,255,255,0.5);
            z-index: 40;
        }

        /* ── Category Labels ── */
        .cat-label {
            position: absolute; pointer-events: none;
            font-family: 'Cinzel', serif; font-size: 10px; font-weight: 700; letter-spacing: 0.4em;
            text-transform: uppercase;
            transform: translate(-50%, -50%);
            opacity: 0; white-space: nowrap; z-index: 15;
            text-shadow: 0 2px 10px rgba(0,0,0,0.8);
        }

        /* ── HUD ── */
        #hud {
            position: fixed; top: 40px; left: 40px;
            pointer-events: none; z-index: 50;
        }
        #hud-name {
            font-family: 'Cinzel', serif; font-size: 24px; font-weight: 700; letter-spacing: 0.2em;
            text-transform: uppercase; margin-bottom: 8px;
            text-shadow: 0 0 20px rgba(var(--primary-glow), 0.4);
        }
        #hud-sub {
            font-size: 11px; letter-spacing: 0.25em; color: rgba(255,255,255,0.6);
            text-transform: uppercase; font-weight: 400;
        }

        #hud-hint {
            position: fixed; bottom: 40px; left: 50%; transform: translateX(-50%);
            font-size: 10px; letter-spacing: 0.3em; color: rgba(255,255,255,0.4);
            text-transform: uppercase; pointer-events: none;
            background: rgba(0,0,0,0.4); padding: 8px 16px; border-radius: 20px;
            backdrop-filter: blur(4px); border: 1px solid rgba(255,255,255,0.05);
            transition: opacity 0.5s;
        }

        /* ── Detail Panel ── */
        #detail-panel {
            position: fixed; top: 50%; right: 40px; transform: translateY(-50%) translateX(40px);
            width: 280px; background: var(--glass-bg);
            backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px);
            border: 1px solid var(--glass-border); border-radius: 12px;
            padding: 30px 24px; pointer-events: auto;
            opacity: 0; visibility: hidden;
            transition: all 0.6s cubic-bezier(0.16, 1, 0.3, 1);
            z-index: 60; box-shadow: 0 20px 40px rgba(0,0,0,0.6), inset 0 0 0 1px rgba(255,255,255,0.05);
        }
        #detail-panel.visible {
            opacity: 1; visibility: visible; transform: translateY(-50%) translateX(0);
        }
        #panel-close {
            position: absolute; top: 16px; right: 16px;
            font-size: 18px; color: rgba(255,255,255,0.4); cursor: pointer;
            transition: color 0.3s, transform 0.3s;
        }
        #panel-close:hover { color: white; transform: scale(1.1) rotate(90deg); }
        
        #panel-cat { font-family: 'Cinzel', serif; font-size: 9px; letter-spacing: 0.3em; text-transform: uppercase; margin-bottom: 12px; }
        #panel-title { font-size: 28px; font-weight: 300; margin-bottom: 24px; letter-spacing: 0.05em; line-height: 1.1; }
        
        .prof-container { margin-bottom: 8px; }
        .prof-header { display: flex; justify-content: space-between; font-size: 10px; letter-spacing: 0.1em; color: rgba(255,255,255,0.7); margin-bottom: 8px; text-transform: uppercase;}
        .prof-track { width: 100%; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; overflow: hidden; position: relative;}
        .prof-fill { height: 100%; width: 0%; border-radius: 2px; transition: width 1.2s cubic-bezier(0.16, 1, 0.3, 1); box-shadow: 0 0 10px currentColor; }

        /* ── Controls ── */
        #btn-reset {
            position: fixed; bottom: 40px; right: 40px;
            background: var(--glass-bg); border: 1px solid var(--glass-border);
            backdrop-filter: blur(8px); padding: 12px 24px; border-radius: 30px;
            color: white; font-family: 'Montserrat', sans-serif; font-size: 11px; font-weight: 600;
            letter-spacing: 0.2em; text-transform: uppercase; cursor: pointer;
            opacity: 0; pointer-events: none; transform: translateY(10px);
            transition: all 0.4s ease; z-index: 50; box-shadow: 0 8px 24px rgba(0,0,0,0.4);
        }
        #btn-reset.visible { opacity: 1; pointer-events: auto; transform: translateY(0); }
        #btn-reset:hover { background: rgba(255,255,255,0.1); border-color: rgba(255,255,255,0.3); }

        /* Vignette */
        #vignette {
            position: fixed; inset: 0; pointer-events: none; z-index: 5;
            background: radial-gradient(circle at 50% 50%, transparent 40%, rgba(0,2,5,0.85) 150%);
        }

        @media (max-width: 768px) {
            #hud { top: 24px; left: 24px; }
            #hud-name { font-size: 18px; }
            #detail-panel { top: auto; bottom: 20px; right: 20px; left: 20px; transform: translateY(20px); width: auto; }
            #detail-panel.visible { transform: translateY(0); }
            #btn-reset { bottom: auto; top: 24px; right: 24px; }
        }
    </style>
    
    <!-- Import Maps for Three.js and Addons -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "@tweenjs/tween.js": "https://unpkg.com/@tweenjs/tween.js@23.1.1/dist/tween.esm.js"
            }
        }
    </script>
</head>
<body>

    <!-- Loading Screen -->
    <div id="loader">
        <div class="loader-ring"></div>
        <div id="loader-title">Synthesizing Skills</div>
    </div>

    <div id="app-container">
        <canvas id="webgl-canvas"></canvas>
        <svg id="svg-overlay"></svg>
        <div id="vignette"></div>

        <div id="hud">
            <div id="hud-name">Anbu Malligarjun</div>
            <div id="hud-sub">AI · Biology · Education</div>
        </div>

        <div id="hud-hint">Drag to Rotate</div>

        <div id="detail-panel">
            <div id="panel-close">✕</div>
            <div id="panel-cat">Category</div>
            <div id="panel-title">Skill Name</div>
            <div class="prof-container">
                <div class="prof-header">
                    <span>Proficiency</span>
                    <span id="panel-prof-val">0%</span>
                </div>
                <div class="prof-track">
                    <div id="panel-fill" class="prof-fill"></div>
                </div>
            </div>
        </div>

        <button id="btn-reset">Return to Canopy</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
        import TWEEN from '@tweenjs/tween.js';

        // ═══════════════════════════════════════════════
        // DATA DEFINITION
        // ═══════════════════════════════════════════════
        const CATEGORIES = [
            {
                name: 'Languages', color: '#00f0ff',
                skills: [
                    { label: 'Python', prof: 95 }, { label: 'JavaScript', prof: 88 },
                    { label: 'Java', prof: 80 }, { label: 'C++', prof: 75 },
                    { label: 'HTML/CSS', prof: 92 }, { label: 'MySQL', prof: 82 }, { label: 'C', prof: 70 }
                ]
            },
            {
                name: 'Technical', color: '#b53cff',
                skills: [
                    { label: 'Machine Learning', prof: 90 }, { label: 'Deep Learning', prof: 85 },
                    { label: 'LLM Fine-tuning', prof: 82 }, { label: 'RAG', prof: 80 },
                    { label: 'Data Analysis', prof: 88 }, { label: 'UI/UX', prof: 78 }, { label: 'Manim Viz', prof: 75 }
                ]
            },
            {
                name: 'Frameworks', color: '#00ff73',
                skills: [
                    { label: 'TensorFlow', prof: 85 }, { label: 'Scikit-Learn', prof: 88 },
                    { label: 'Hugging Face', prof: 82 }, { label: 'Pandas', prof: 92 },
                    { label: 'NumPy', prof: 93 }, { label: 'Matplotlib', prof: 87 }, { label: 'Seaborn', prof: 80 }
                ]
            },
            {
                name: 'Tools', color: '#ffaa00',
                skills: [
                    { label: 'AWS', prof: 75 }, { label: 'Git', prof: 90 },
                    { label: 'Figma', prof: 82 }, { label: 'Jupyter', prof: 93 },
                    { label: 'Framer', prof: 72 }, { label: 'WebFlow', prof: 70 }, { label: 'VS Code', prof: 95 }
                ]
            }
        ];

        // ═══════════════════════════════════════════════
        // CORE SETUP
        // ═══════════════════════════════════════════════
        const canvas = document.getElementById('webgl-canvas');
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, powerPreference: "high-performance" });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x03070b, 0.012);

        // Camera setup
        const defaultCamPos = new THREE.Vector3(0, 18, 55);
        const defaultCamTarget = new THREE.Vector3(0, 15, 0);
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.copy(defaultCamPos);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        // Disable mouse-wheel zoom so page scrolling works normally
        controls.enableZoom = false;
        controls.maxDistance = 100;
        controls.minDistance = 10;
        controls.maxPolarAngle = Math.PI / 2 + 0.1; // Don't go too far below ground
        controls.target.copy(defaultCamTarget);

        // Post-Processing (Bloom)
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.6, 0.8, 0.2);
        bloomPass.strength = 1.2;
        bloomPass.radius = 0.6;
        bloomPass.threshold = 0.1;
        const outputPass = new OutputPass();

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);
        composer.addPass(outputPass);

        // ═══════════════════════════════════════════════
        // ENVIRONMENT & LIGHTING
        // ═══════════════════════════════════════════════
        // Deep space background with subtle stars
        scene.background = new THREE.Color(0x03070b);
        const starGeo = new THREE.BufferGeometry();
        const starCount = 1500;
        const starPos = new Float32Array(starCount * 3);
        for(let i=0; i<starCount; i++){
            const r = 200 + Math.random() * 200;
            const theta = 2 * Math.PI * Math.random();
            const phi = Math.acos(2 * Math.random() - 1);
            starPos[i*3] = r * Math.sin(phi) * Math.cos(theta);
            starPos[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
            starPos[i*3+2] = r * Math.cos(phi);
        }
        starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
        const starMat = new THREE.PointsMaterial({color: 0xffffff, size: 0.8, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending});
        scene.add(new THREE.Points(starGeo, starMat));

        // Ground
        const groundGeo = new THREE.PlaneGeometry(200, 200, 32, 32);
        // Slightly displace ground
        const pos = groundGeo.attributes.position;
        for(let i=0; i<pos.count; i++){
            pos.setZ(i, (Math.random()-0.5) * 2.0);
        }
        groundGeo.computeVertexNormals();
        const groundMat = new THREE.MeshStandardMaterial({ color: 0x05080c, roughness: 0.8, metalness: 0.1 });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Lights
        const ambient = new THREE.AmbientLight(0x0a1525, 2.0);
        scene.add(ambient);
        
        const moonLight = new THREE.DirectionalLight(0x88bbff, 1.5);
        moonLight.position.set(-20, 50, -20);
        moonLight.castShadow = true;
        moonLight.shadow.mapSize.width = 2048;
        moonLight.shadow.mapSize.height = 2048;
        moonLight.shadow.camera.near = 10;
        moonLight.shadow.camera.far = 150;
        moonLight.shadow.camera.left = -40;
        moonLight.shadow.camera.right = 40;
        moonLight.shadow.camera.top = 40;
        moonLight.shadow.camera.bottom = -40;
        moonLight.shadow.bias = -0.001;
        scene.add(moonLight);

        const rimLight = new THREE.DirectionalLight(0xffffff, 0.5);
        rimLight.position.set(20, 10, 30);
        scene.add(rimLight);

        // Core glow light
        const coreLight = new THREE.PointLight(0x00f0ff, 2, 40);
        coreLight.position.set(0, 10, 0);
        scene.add(coreLight);

        // ═══════════════════════════════════════════════
        // PROCEDURAL TREE GENERATION (Smooth Curves)
        // ═══════════════════════════════════════════════
        const treeGroup = new THREE.Group();
        scene.add(treeGroup);

        const barkMat = new THREE.MeshStandardMaterial({ 
            color: 0x0a0a0d, 
            roughness: 0.9, 
            metalness: 0.2,
            bumpScale: 0.05
        });

        const skillNodes = []; 
        const catPositions = [];

        // Helper to create a smooth curving tube branch
        function createBranchCurve(start, end, midOffset, radiusStart, radiusEnd) {
            const mid = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5).add(midOffset);
            const curve = new THREE.CatmullRomCurve3([start, mid, end]);
            const geo = new THREE.TubeGeometry(curve, 16, radiusStart, 8, false);
            
            // Taper the geometry
            const pos = geo.attributes.position;
            for(let i=0; i<pos.count; i++){
                const u = geo.parameters.path.getUtoTmapping(i / pos.count); // rough approximation
                // To do true taper we manipulate vertices based on their along-curve distance
            }
            // A simpler taper implementation for TubeGeometry:
            // Modify vertex distances from curve
            const tubeVerts = geo.attributes.position;
            const uvs = geo.attributes.uv;
            for(let i=0; i<tubeVerts.count; i++) {
                const u = uvs.getX(i); // 0 to 1 along the tube
                const r = THREE.MathUtils.lerp(radiusStart, radiusEnd, u);
                
                // Get point on curve
                const pt = curve.getPointAt(u);
                const vt = new THREE.Vector3().fromBufferAttribute(tubeVerts, i);
                const dir = new THREE.Vector3().subVectors(vt, pt).normalize();
                
                vt.copy(pt).add(dir.multiplyScalar(r));
                
                // Add gnarliness
                vt.x += (Math.random()-0.5)*r*0.3;
                vt.y += (Math.random()-0.5)*r*0.3;
                vt.z += (Math.random()-0.5)*r*0.3;
                
                tubeVerts.setXYZ(i, vt.x, vt.y, vt.z);
            }
            geo.computeVertexNormals();
            const mesh = new THREE.Mesh(geo, barkMat);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            treeGroup.add(mesh);
            return curve;
        }

        // Generate Trunk
        const trunkStart = new THREE.Vector3(0, -2, 0);
        const trunkEnd = new THREE.Vector3(0, 12, 0);
        const trunkMidOffset = new THREE.Vector3((Math.random()-0.5)*2, 0, (Math.random()-0.5)*2);
        createBranchCurve(trunkStart, trunkEnd, trunkMidOffset, 1.8, 1.0);

        // Generate Main Category Branches
        const mainBranches = [];
        CATEGORIES.forEach((cat, i) => {
            const angle = (i / CATEGORIES.length) * Math.PI * 2 + Math.PI/4;
            const length = 18 + Math.random() * 6;
            const height = 15 + Math.random() * 8;
            
            const end = new THREE.Vector3(
                Math.cos(angle) * length,
                trunkEnd.y + height,
                Math.sin(angle) * length
            );
            
            const midOffset = new THREE.Vector3(
                Math.cos(angle) * length * 0.4,
                -2 + Math.random()*4,
                Math.sin(angle) * length * 0.4
            );

            createBranchCurve(trunkEnd, end, midOffset, 0.9, 0.3);
            
            // Save pos for category label (slightly above mid point)
            const catPos = new THREE.Vector3().lerpVectors(trunkEnd, end, 0.6).add(new THREE.Vector3(0, 4, 0));
            catPositions.push({ pos: catPos, name: cat.name, color: cat.color });

            mainBranches.push({ endPos: end, angle: angle, cat: cat });
        });

        // Generate Sub-branches & Skill Nodes
        mainBranches.forEach(branch => {
            const numSkills = branch.cat.skills.length;
            
            branch.cat.skills.forEach((skill, j) => {
                // Distribute in a semi-sphere around branch end
                const subAngle = (j / numSkills) * Math.PI * 2;
                const spread = 6 + Math.random() * 3;
                const hOffset = -2 + Math.random() * 6;
                
                const skillPos = new THREE.Vector3(
                    branch.endPos.x + Math.cos(subAngle) * spread,
                    branch.endPos.y + hOffset,
                    branch.endPos.z + Math.sin(subAngle) * spread
                );

                const midOffset = new THREE.Vector3(0, Math.random()*3, 0);
                createBranchCurve(branch.endPos, skillPos, midOffset, 0.25, 0.05);

                // Add mystical glowing orb at the end
                const color = new THREE.Color(branch.cat.color);
                
                // Core
                const orbGeo = new THREE.SphereGeometry(0.25, 16, 16);
                const orbMat = new THREE.MeshStandardMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 2.0,
                    roughness: 0.2,
                    transparent: true,
                    opacity: 0.9
                });
                const orb = new THREE.Mesh(orbGeo, orbMat);
                orb.position.copy(skillPos);
                treeGroup.add(orb);

                // Glow Sprite
                const canvasGlow = document.createElement('canvas');
                canvasGlow.width = 64; canvasGlow.height = 64;
                const ctx = canvasGlow.getContext('2d');
                const grd = ctx.createRadialGradient(32,32,0, 32,32,32);
                grd.addColorStop(0, color.getStyle());
                grd.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grd;
                ctx.fillRect(0,0,64,64);
                
                const tex = new THREE.CanvasTexture(canvasGlow);
                const spriteMat = new THREE.SpriteMaterial({ map: tex, blending: THREE.AdditiveBlending, depthWrite: false });
                const sprite = new THREE.Sprite(spriteMat);
                sprite.scale.set(3, 3, 1);
                sprite.position.copy(skillPos);
                treeGroup.add(sprite);

                skillNodes.push({
                    pos: skillPos,
                    skill: skill,
                    category: branch.cat,
                    mesh: orb,
                    sprite: sprite
                });
            });
        });

        // Add Base Roots
        for(let i=0; i<8; i++) {
            const a = (i/8)*Math.PI*2 + Math.random();
            const l = 8 + Math.random()*10;
            const end = new THREE.Vector3(Math.cos(a)*l, -1.5, Math.sin(a)*l);
            const mid = new THREE.Vector3(Math.cos(a)*l*0.5, 1.0, Math.sin(a)*l*0.5);
            createBranchCurve(trunkStart, end, mid, 1.2, 0.1);
        }

        // Floating Particles (Fireflies/Energy)
        const pCount = 300;
        const pGeo = new THREE.BufferGeometry();
        const pPos = new Float32Array(pCount * 3);
        const pSpeed = new Float32Array(pCount);
        const pPhase = new Float32Array(pCount);

        for(let i=0; i<pCount; i++){
            pPos[i*3] = (Math.random()-0.5)*60;
            pPos[i*3+1] = Math.random()*40;
            pPos[i*3+2] = (Math.random()-0.5)*60;
            pSpeed[i] = 0.01 + Math.random()*0.02;
            pPhase[i] = Math.random() * Math.PI * 2;
        }
        pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
        pGeo.setAttribute('speed', new THREE.BufferAttribute(pSpeed, 1));
        pGeo.setAttribute('phase', new THREE.BufferAttribute(pPhase, 1));

        const pMat = new THREE.PointsMaterial({
            color: 0x00ffff, size: 0.15, transparent: true, opacity: 0.8,
            blending: THREE.AdditiveBlending, depthWrite: false
        });
        const particles = new THREE.Points(pGeo, pMat);
        scene.add(particles);

        // ═══════════════════════════════════════════════
        // UI & INTERACTION LOGIC
        // ═══════════════════════════════════════════════
        const appContainer = document.getElementById('app-container');
        const svgOverlay = document.getElementById('svg-overlay');
        const detailPanel = document.getElementById('detail-panel');
        const btnReset = document.getElementById('btn-reset');
        const hudHint = document.getElementById('hud-hint');
        
        const domElements = []; // To sync 3D pos to 2D screen

        // Create UI elements for Skills
        skillNodes.forEach((node, i) => {
            const div = document.createElement('div');
            div.className = 'skill-tag';
            div.textContent = node.skill.label;
            div.style.color = node.category.color;
            div.style.animationDelay = (i * 0.05) + 's';
            appContainer.appendChild(div);

            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('stroke', node.category.color);
            line.setAttribute('stroke-width', '1.5');
            line.setAttribute('stroke-opacity', '0.4');
            // Adding a glowing filter to lines
            line.style.filter = `drop-shadow(0 0 4px ${node.category.color})`;
            svgOverlay.appendChild(line);

            // Hover Effects
            div.addEventListener('mouseenter', () => {
                if(activeNode !== node) {
                    new TWEEN.Tween(node.mesh.scale)
                        .to({x: 1.8, y: 1.8, z: 1.8}, 300)
                        .easing(TWEEN.Easing.Back.Out).start();
                }
            });
            div.addEventListener('mouseleave', () => {
                if(activeNode !== node) {
                    new TWEEN.Tween(node.mesh.scale)
                        .to({x: 1, y: 1, z: 1}, 300)
                        .easing(TWEEN.Easing.Quadratic.Out).start();
                }
            });

            // Click Effect (Zoom)
            div.addEventListener('click', () => {
                focusOnNode(node, div);
            });

            domElements.push({ pos3D: node.pos, div: div, line: line, type: 'skill', node: node });
        });

        // Create Category Labels
        catPositions.forEach((cat, i) => {
            const div = document.createElement('div');
            div.className = 'cat-label';
            div.textContent = cat.name;
            div.style.color = cat.color;
            div.style.animationDelay = (i * 0.2) + 's';
            appContainer.appendChild(div);
            domElements.push({ pos3D: cat.pos, div: div, type: 'cat' });
        });

        let activeNode = null;
        let activeDiv = null;

        function focusOnNode(node, div) {
            hudHint.style.opacity = '0';
            
            // Reset previous
            if(activeNode) {
                activeDiv.classList.remove('active');
                new TWEEN.Tween(activeNode.mesh.scale).to({x:1,y:1,z:1}, 400).start();
            }

            activeNode = node;
            activeDiv = div;
            div.classList.add('active');

            // Animate node scale
            new TWEEN.Tween(node.mesh.scale)
                .to({x: 2.5, y: 2.5, z: 2.5}, 600)
                .easing(TWEEN.Easing.Elastic.Out).start(); // Fix applied here

            // Calculate Camera position (offset towards camera, slightly up)
            const targetPos = node.pos.clone();
            const direction = targetPos.clone().sub(defaultCamTarget).normalize();
            const camEndPos = targetPos.clone().add(direction.multiplyScalar(12)).add(new THREE.Vector3(0, 4, 0));

            // Tween Camera Position
            new TWEEN.Tween(camera.position)
                .to({ x: camEndPos.x, y: camEndPos.y, z: camEndPos.z }, 1200)
                .easing(TWEEN.Easing.Cubic.InOut)
                .start();

            // Tween Camera Target (OrbitControls target)
            new TWEEN.Tween(controls.target)
                .to({ x: targetPos.x, y: targetPos.y, z: targetPos.z }, 1200)
                .easing(TWEEN.Easing.Cubic.InOut)
                .start();

            // Populate Panel
            document.getElementById('panel-cat').textContent = node.category.name;
            document.getElementById('panel-cat').style.color = node.category.color;
            document.getElementById('panel-title').textContent = node.skill.label;
            document.getElementById('panel-prof-val').textContent = node.skill.prof + '%';
            
            const fill = document.getElementById('panel-fill');
            fill.style.width = '0%';
            fill.style.backgroundColor = node.category.color;
            fill.style.color = node.category.color; // for box-shadow
            
            detailPanel.classList.add('visible');
            btnReset.classList.add('visible');

            setTimeout(() => { fill.style.width = node.skill.prof + '%'; }, 600);
        }

        function resetView() {
            if(!activeNode) return;
            
            activeDiv.classList.remove('active');
            new TWEEN.Tween(activeNode.mesh.scale).to({x:1,y:1,z:1}, 400).start();
            
            activeNode = null;
            activeDiv = null;
            
            detailPanel.classList.remove('visible');
            btnReset.classList.remove('visible');
            hudHint.style.opacity = '1';

            new TWEEN.Tween(camera.position)
                .to({ x: defaultCamPos.x, y: defaultCamPos.y, z: defaultCamPos.z }, 1500)
                .easing(TWEEN.Easing.Cubic.InOut)
                .start();

            new TWEEN.Tween(controls.target)
                .to({ x: defaultCamTarget.x, y: defaultCamTarget.y, z: defaultCamTarget.z }, 1500)
                .easing(TWEEN.Easing.Cubic.InOut)
                .start();
        }

        btnReset.addEventListener('click', resetView);
        document.getElementById('panel-close').addEventListener('click', resetView);

        // Update 2D positions based on 3D projection
        function updateDOM() {
            const widthHalf = window.innerWidth / 2;
            const heightHalf = window.innerHeight / 2;

            domElements.forEach(item => {
                const vector = item.pos3D.clone();
                vector.project(camera);

                // Check if behind camera
                if(vector.z > 1) {
                    item.div.style.opacity = 0;
                    if(item.line) item.line.style.opacity = 0;
                    return;
                }

                const x = (vector.x * widthHalf) + widthHalf;
                const y = -(vector.y * heightHalf) + heightHalf;

                item.div.style.left = `${x}px`;
                item.div.style.top = `${y}px`;

                // Fade out tags that are too close or too far
                const dist = camera.position.distanceTo(item.pos3D);
                let opacity = 1;
                if(item.type === 'cat') {
                    opacity = dist > 40 ? 1 : Math.max(0, (dist - 20)/20);
                } else {
                    opacity = dist > 60 ? Math.max(0, 1 - (dist-60)/30) : 1;
                    if(activeNode && item.node !== activeNode) opacity *= 0.3; // Dim others when focused
                }
                
                item.div.style.opacity = opacity;

                if (item.line) {
                    // Start line from slightly below the tag, end at actual 3D center
                    item.line.setAttribute('x1', x);
                    item.line.setAttribute('y1', y + 14);
                    item.line.setAttribute('x2', x);
                    item.line.setAttribute('y2', y + 20); // Short connector line for elegance
                    item.line.style.opacity = opacity * 0.8;
                }
            });
        }

        // ═══════════════════════════════════════════════
        // RENDER LOOP & ANIMATION
        // ═══════════════════════════════════════════════
        const clock = new THREE.Clock();

        function animate(time) {
            requestAnimationFrame(animate);
            TWEEN.update(time);
            controls.update();

            const delta = clock.getDelta();
            const elapsed = clock.getElapsedTime();

            // Gently rotate tree group to feel alive
            treeGroup.rotation.y = Math.sin(elapsed * 0.1) * 0.05;
            treeGroup.position.y = Math.sin(elapsed * 0.5) * 0.2;

            // Pulse Orbs and Sprites
            skillNodes.forEach((node, i) => {
                const pulse = Math.sin(elapsed * 2 + i) * 0.5 + 0.5;
                node.sprite.scale.setScalar(3 + pulse * 1.5);
                node.sprite.material.opacity = 0.4 + pulse * 0.4;
                if(node !== activeNode) {
                    node.mesh.material.emissiveIntensity = 1.5 + pulse;
                } else {
                    node.mesh.material.emissiveIntensity = 3.0 + pulse*2;
                    node.sprite.scale.setScalar(6 + pulse * 2);
                }
            });

            // Animate Particles
            const positions = particles.geometry.attributes.position.array;
            for(let i=0; i<pCount; i++) {
                positions[i*3+1] += pSpeed[i];
                positions[i*3] += Math.sin(elapsed + pPhase[i]) * 0.01;
                positions[i*3+2] += Math.cos(elapsed + pPhase[i]) * 0.01;

                if(positions[i*3+1] > 40) {
                    positions[i*3+1] = 0;
                }
            }
            particles.geometry.attributes.position.needsUpdate = true;
            
            // Core Light pulse
            coreLight.intensity = 2 + Math.sin(elapsed * 3) * 0.5;

            updateDOM();
            
            // Render via composer for Bloom
            composer.render();
        }

        // ═══════════════════════════════════════════════
        // INITIALIZATION
        // ═══════════════════════════════════════════════
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        // Intro sequence
        setTimeout(() => {
            const loader = document.getElementById('loader');
            loader.style.opacity = '0';
            setTimeout(() => {
                loader.remove();
                // Pop in tags
                document.querySelectorAll('.skill-tag, .cat-label').forEach(el => {
                    el.style.animation = 'tagIn 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards';
                });
            }, 1200);
        }, 1500);

        // Add intro keyframe
        const style = document.createElement('style');
        style.textContent = `
            @keyframes tagIn {
                0% { opacity: 0; transform: translate(-50%, -30%) scale(0.8); }
                100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            }
        `;
        document.head.appendChild(style);

        animate();
    </script>
</body>
</html>